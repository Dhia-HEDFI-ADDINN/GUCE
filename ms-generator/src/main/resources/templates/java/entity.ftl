package cm.guce.${moduleName}.domain.model;

<#if extendsBaseEntity>
import cm.guce.common.domain.model.BaseEntity;
</#if>
import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
<#list attributes as attr>
<#if attr.dataType.name() == "DECIMAL" || attr.dataType.name() == "CURRENCY" || attr.dataType.name() == "PERCENTAGE">
import java.math.BigDecimal;
<#break>
</#if>
</#list>
<#list attributes as attr>
<#if attr.dataType.name() == "DATE">
import java.time.LocalDate;
<#break>
</#if>
</#list>
<#list attributes as attr>
<#if attr.dataType.name() == "DATETIME">
import java.time.LocalDateTime;
<#break>
</#if>
</#list>
<#list attributes as attr>
<#if attr.dataType.name() == "UUID">
import java.util.UUID;
<#break>
</#if>
</#list>
<#list relations as rel>
<#if rel.relationType.name() == "ONE_TO_MANY" || rel.relationType.name() == "MANY_TO_MANY">
import java.util.ArrayList;
import java.util.List;
<#break>
</#if>
</#list>

/**
 * ${descriptionFr!"Entité " + className}
 *
 * @generated by GUCE Low-Code Generator
 * @version ${generatorVersion}
 */
@Entity
@Table(name = "${tableName}"<#if searchableAttributes?has_content>, indexes = {
<#list searchableAttributes as attr>
        @Index(name = "idx_${tableName}_${attr.snakeCaseColumnName}", columnList = "${attr.snakeCaseColumnName}")<#if attr_has_next>,</#if>
</#list>
}</#if>)
@Getter
@Setter
@NoArgsConstructor
public class ${className} <#if extendsBaseEntity>extends BaseEntity</#if> {

${generatedStart}
<#list attributes as attr>

    <#if attr.dataType.name() == "ENUM">
    @Enumerated(EnumType.STRING)
    </#if>
    @Column(name = "${attr.snakeCaseColumnName}"<#if attr.isRequired>, nullable = false</#if><#if attr.isUnique>, unique = true</#if><#if attr.maxLength??>, length = ${attr.maxLength}</#if><#if attr.precisionValue??>, precision = ${attr.precisionValue}<#if attr.scaleValue??>, scale = ${attr.scaleValue}</#if></#if>)
    private ${attr.javaTypeResolved} ${attr.name}<#if attr.defaultValue??> = ${attr.defaultValue}</#if>;
</#list>

<#list relations as rel>

    <#if rel.relationType.name() == "MANY_TO_ONE">
    @ManyToOne(fetch = FetchType.${rel.fetchType.name()})
    @JoinColumn(name = "${rel.joinColumn!"${rel.name?lower_case}_id"}")
    <#elseif rel.relationType.name() == "ONE_TO_MANY">
    @OneToMany(mappedBy = "${rel.mappedBy}", cascade = CascadeType.${rel.cascadeType!"ALL"}<#if rel.orphanRemoval>, orphanRemoval = true</#if>)
    <#elseif rel.relationType.name() == "ONE_TO_ONE">
    @OneToOne(fetch = FetchType.${rel.fetchType.name()})
    @JoinColumn(name = "${rel.joinColumn!"${rel.name?lower_case}_id"}")
    <#elseif rel.relationType.name() == "MANY_TO_MANY">
    @ManyToMany
    @JoinTable(name = "${rel.joinTable!"${tableName}_${rel.name?lower_case}"}")
    </#if>
    private <#if rel.relationType.name() == "ONE_TO_MANY" || rel.relationType.name() == "MANY_TO_MANY">List<${rel.targetEntity.className}><#else>${rel.targetEntity.className}</#if> ${rel.name}<#if rel.relationType.name() == "ONE_TO_MANY" || rel.relationType.name() == "MANY_TO_MANY"> = new ArrayList<>()</#if>;
</#list>
${generatedEnd}

${customStart}
    // Zone de code personnalisé - Préservée lors de la régénération
    // Ajoutez ici vos méthodes métier personnalisées
${customEnd}

<#list attributes as attr>
<#if attr.dataType.name() == "ENUM">

    public enum ${attr.name?cap_first} {
        <#list attr.enumValues?split(",") as val>
        ${val?trim}<#if val_has_next>,</#if>
        </#list>
    }
</#if>
</#list>
}
